<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Play Gate - X Connect & Phantom Wallet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer></script>
    <script src="supabase_config.js" defer></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        background: 'hsl(220, 13%, 9%)',
                        foreground: 'hsl(220, 13%, 91%)',
                        card: 'hsl(220, 13%, 11%)',
                        'card-foreground': 'hsl(220, 13%, 91%)',
                        primary: 'hsl(217, 91%, 60%)',
                        'primary-foreground': 'hsl(220, 13%, 9%)',
                        secondary: 'hsl(220, 13%, 15%)',
                        'secondary-foreground': 'hsl(220, 13%, 91%)',
                        muted: 'hsl(220, 13%, 15%)',
                        'muted-foreground': 'hsl(220, 9%, 46%)',
                        accent: 'hsl(262, 83%, 58%)',
                        'accent-foreground': 'hsl(220, 13%, 91%)',
                        border: 'hsl(220, 13%, 15%)',
                        'gaming-primary': 'hsl(217, 91%, 60%)',
                        'gaming-secondary': 'hsl(262, 83%, 58%)',
                        'gaming-accent': 'hsl(174, 100%, 29%)',
                    },
                    backgroundImage: {
                        'gradient-primary': 'linear-gradient(135deg, hsl(217, 91%, 60%), hsl(262, 83%, 58%))',
                        'gradient-gaming': 'linear-gradient(135deg, hsl(174, 100%, 29%), hsl(217, 91%, 60%))',
                        'gradient-glass': 'linear-gradient(135deg, hsl(220, 13%, 11%, 0.8), hsl(220, 13%, 15%, 0.6))',
                        'gradient-phantom': 'linear-gradient(45deg, #9945ff, #14f195)',
                        'gradient-x': 'linear-gradient(45deg, #1da1f2, #0d8bd9)',
                    },
                    backdropBlur: {
                        'glass': '20px',
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-in-out',
                        'slide-up': 'slideUp 0.3s ease-out',
                        'pulse-gaming': 'pulseGaming 2s infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'scale(0.95)' },
                            '100%': { opacity: '1', transform: 'scale(1)' }
                        },
                        slideUp: {
                            '0%': { opacity: '0', transform: 'translateY(20px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' }
                        },
                        pulseGaming: {
                            '0%, 100%': { boxShadow: '0 0 20px rgba(59, 130, 246, 0.3)' },
                            '50%': { boxShadow: '0 0 40px rgba(59, 130, 246, 0.6)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .glass-effect {
            background: linear-gradient(135deg, rgba(34, 40, 49, 0.8), rgba(45, 52, 64, 0.6));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .gaming-glow {
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }
        .card-hover-glow {
            transition: all 0.3s ease;
        }
        .card-hover-glow:hover {
            box-shadow: 0 0 40px rgba(59, 130, 246, 0.6), 0 0 80px rgba(59, 130, 246, 0.3);
            transform: translateY(-5px);
        }
        .phantom-glow {
            box-shadow: 0 0 30px rgba(153, 69, 255, 0.3);
        }
        .x-glow {
            box-shadow: 0 0 30px rgba(29, 161, 242, 0.3);
        }
    </style>
</head>
<body class="min-h-screen bg-background text-foreground">
    <!-- Liquid Glass Welcome Modal -->
    <div id="welcomeModal" class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-background/20 backdrop-blur-md"></div>
        <div class="relative z-10 glass-effect rounded-3xl p-12 mx-4 shadow-2xl animate-fade-in">
            <div class="text-center space-y-8">
                <div class="space-y-4">
                    <h1 class="text-6xl font-bold bg-gradient-primary bg-clip-text text-transparent">
                        Ready to Play?
                    </h1>
                    <p class="text-xl text-muted-foreground">
                        Enter the ultimate crypto gaming experience
                    </p>
                </div>
                <button 
                    onclick="closeWelcomeModal()"
                    class="px-12 py-6 text-xl font-semibold bg-gradient-primary hover:opacity-90 transition-opacity shadow-lg rounded-lg border-0 text-primary-foreground"
                >
                    Yes, Let's Go!
                </button>
            </div>
        </div>
    </div>

    <!-- Main Dashboard -->
    <div id="mainDashboard" class="hidden min-h-screen">
        <div class="flex">
            <!-- Main Content -->
            <div class="flex-1 p-6">


                <!-- Header with Auth Buttons -->
                <header class="flex items-center justify-between mb-8">
                    <div class="flex items-center gap-4">
                        <button 
                            id="phantomConnectBtn"
                            onclick="connectPhantom()"
                            class="flex items-center gap-2 px-6 py-3 bg-gradient-phantom hover:opacity-90 transition-opacity rounded-lg text-white font-semibold phantom-glow"
                        >
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                            </svg>
                            Phantom Wallet
                        </button>
                        
                        <button 
                            id="xConnectBtn"
                            onclick="connectX()"
                            class="flex items-center gap-2 px-6 py-3 bg-gradient-x hover:opacity-90 transition-opacity rounded-lg text-white font-semibold x-glow"
                        >
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                            X Connect
                        </button>
                    </div>
                    
                    <div class="flex items-center gap-6">
                        <div class="flex items-center gap-2">
                            <span class="text-sm text-muted-foreground">$COIN Balance:</span>
                            <div class="bg-gradient-gaming text-primary-foreground px-4 py-1 text-lg font-bold rounded-full">
                                1,847.50 $COIN
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <span class="text-sm text-muted-foreground">User XP:</span>
                            <div class="bg-gradient-primary text-primary-foreground px-4 py-1 text-lg font-bold rounded-full">
                                3,250 XP
                            </div>
                        </div>
                    </div>
                </header>

                <!-- Status Display -->
                <div id="status" class="mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center"></div>

                <!-- BTC Price Card -->
                <div class="glass-effect rounded-2xl p-6 mb-8 card-hover-glow">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-2xl font-bold bg-gradient-primary bg-clip-text text-transparent">
                            BTC Live Price
                        </h2>
                        <div class="flex items-center gap-2">
                            <div id="priceStatus" class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                            <span class="text-xs text-muted-foreground">Live</span>
                        </div>
                    </div>
                    
                    <!-- Price Stats -->
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                        <div class="text-center">
                            <div class="text-sm text-muted-foreground">Current Price</div>
                            <div id="currentPrice" class="text-3xl font-bold text-gaming-accent">Loading...</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-muted-foreground">24h Change</div>
                            <div id="priceChange" class="text-xl font-semibold">Loading...</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-muted-foreground">24h High</div>
                            <div id="priceHigh" class="text-xl font-semibold text-gaming-primary">Loading...</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-muted-foreground">24h Low</div>
                            <div id="priceLow" class="text-xl font-semibold text-gaming-secondary">Loading...</div>
                        </div>
                    </div>
                    
                    <!-- Chart Time Filters -->
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-2">
                            <span class="text-sm text-muted-foreground">Timeframe:</span>
                            <div class="flex gap-1">
                                <button onclick="changeTimeframe('15m')" id="filter-15m" class="px-3 py-1 text-xs rounded-md bg-secondary hover:bg-gaming-primary hover:text-white transition-colors">15m</button>
                                <button onclick="changeTimeframe('30m')" id="filter-30m" class="px-3 py-1 text-xs rounded-md bg-secondary hover:bg-gaming-primary hover:text-white transition-colors">30m</button>
                                <button onclick="changeTimeframe('1h')" id="filter-1h" class="px-3 py-1 text-xs rounded-md bg-gaming-primary text-white">1h</button>
                                <button onclick="changeTimeframe('4h')" id="filter-4h" class="px-3 py-1 text-xs rounded-md bg-secondary hover:bg-gaming-primary hover:text-white transition-colors">4h</button>
                            </div>
                        </div>
                        <button onclick="openTradingView()" class="px-4 py-2 text-sm bg-gradient-gaming hover:opacity-90 transition-opacity rounded-lg text-white font-semibold">
                            üìà Advanced Chart
                        </button>
                    </div>
                    
                    <!-- Chart Container -->
                    <div class="bg-background/50 rounded-xl p-4 relative">
                        <div style="position: relative; height: 300px; width: 100%;">
                            <canvas id="btcChart" style="display: block; width: 100%; height: 100%;"></canvas>
                        </div>
                        <div id="chartLoading" class="absolute inset-0 flex items-center justify-center bg-background/80 rounded-xl">
                            <div class="flex items-center gap-3">
                                <div class="w-6 h-6 border-2 border-gaming-primary border-t-transparent rounded-full animate-spin"></div>
                                <span class="text-muted-foreground">Loading chart...</span>
                            </div>
                        </div>
                        <div id="chartError" class="absolute inset-0 hidden items-center justify-center bg-background/80 rounded-xl">
                            <div class="text-center">
                                <div class="text-red-400 mb-2">‚ùå Chart Error</div>
                                <button onclick="retryChart()" class="px-4 py-2 bg-gaming-primary hover:opacity-90 transition-opacity rounded-lg text-white text-sm">
                                    üîÑ Retry
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Modes -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    <div class="glass-effect rounded-2xl p-6 card-hover-glow cursor-pointer group">
                        <div class="text-4xl mb-4">üèÜ</div>
                        <h3 class="text-xl font-bold mb-2 group-hover:text-gaming-primary transition-colors">PVP Ranked</h3>
                        <p class="text-muted-foreground mb-4">Competitive matches with ranking system</p>
                        <button onclick="startGame('PVP Ranked')" class="w-full mt-4 px-4 py-2 bg-gradient-primary hover:opacity-90 transition-opacity rounded-lg text-center text-primary-foreground font-semibold">
                            Play Now
                        </button>
                    </div>
                    
                    <div class="glass-effect rounded-2xl p-6 card-hover-glow cursor-pointer group">
                        <div class="text-4xl mb-4">üéÆ</div>
                        <h3 class="text-xl font-bold mb-2 group-hover:text-gaming-primary transition-colors">Custom Lobby</h3>
                        <p class="text-muted-foreground mb-4">Create or join custom game rooms</p>
                        <button onclick="startGame('Custom Lobby')" class="w-full mt-4 px-4 py-2 bg-gradient-primary hover:opacity-90 transition-opacity rounded-lg text-center text-primary-foreground font-semibold">
                            Play Now
                        </button>
                    </div>
                    
                    <div class="glass-effect rounded-2xl p-6 card-hover-glow cursor-pointer group">
                        <div class="text-4xl mb-4">‚öîÔ∏è</div>
                        <h3 class="text-xl font-bold mb-2 group-hover:text-gaming-primary transition-colors">Battle Royale</h3>
                        <p class="text-muted-foreground mb-4">Last player standing wins all</p>
                        <button onclick="startGame('Battle Royale')" class="w-full mt-4 px-4 py-2 bg-gradient-gaming hover:opacity-90 transition-opacity rounded-lg text-center text-primary-foreground font-semibold">
                            Play Now
                        </button>
                    </div>
                </div>

                <!-- Active Bets Section -->
                <div class="glass-effect rounded-2xl p-6">
                    <h2 class="text-2xl font-bold mb-4 bg-gradient-primary bg-clip-text text-transparent">
                        Active Bets & Queue
                    </h2>
                    
                    <!-- Queue Section -->
                    <div id="queueSection" class="mb-6">
                        <h3 class="text-lg font-semibold mb-3 text-gaming-secondary">üéØ In Queue</h3>
                        <div id="queueList" class="space-y-3">
                            <!-- Queue items will be populated here -->
                        </div>
                        <div id="emptyQueue" class="text-center text-muted-foreground py-4">
                            <div class="text-4xl mb-2">‚è≥</div>
                            <p class="text-sm">No predictions in queue</p>
                        </div>
                    </div>
                    
                    <!-- Active Battles Section -->
                    <div id="activeBattlesSection">
                        <h3 class="text-lg font-semibold mb-3 text-gaming-primary">‚öîÔ∏è Active Battles</h3>
                        <div id="activeBattlesList" class="space-y-3">
                            <!-- Active battles will be populated here -->
                        </div>
                        <div id="emptyBattles" class="text-center text-muted-foreground py-4">
                            <div class="text-4xl mb-2">üéÆ</div>
                            <p class="text-sm">No active battles</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Friends Sidebar -->
            <div class="w-80 p-6 border-l border-border">
                <div class="glass-effect rounded-2xl p-6">
                    <h2 class="text-xl font-bold mb-4 bg-gradient-primary bg-clip-text text-transparent">
                        Friends Online
                    </h2>
                    <div class="space-y-3">
                        <div class="flex items-center gap-3 p-3 rounded-lg bg-secondary/50">
                            <div class="w-8 h-8 bg-gradient-gaming rounded-full"></div>
                            <div>
                                <div class="font-semibold">CryptoKing</div>
                                <div class="text-sm text-muted-foreground">Playing PVP</div>
                            </div>
                            <div class="ml-auto w-2 h-2 bg-green-400 rounded-full"></div>
                        </div>
                        <div class="flex items-center gap-3 p-3 rounded-lg bg-secondary/50">
                            <div class="w-8 h-8 bg-gradient-primary rounded-full"></div>
                            <div>
                                <div class="font-semibold">DiamondHands</div>
                                <div class="text-sm text-muted-foreground">In Queue</div>
                            </div>
                            <div class="ml-auto w-2 h-2 bg-yellow-400 rounded-full"></div>
                        </div>
                        <div class="flex items-center gap-3 p-3 rounded-lg bg-secondary/50">
                            <div class="w-8 h-8 bg-gradient-phantom rounded-full"></div>
                            <div>
                                <div class="font-semibold">Web3Warrior</div>
                                <div class="text-sm text-muted-foreground">Offline</div>
                            </div>
                            <div class="ml-auto w-2 h-2 bg-gray-400 rounded-full"></div>
                        </div>
                    </div>
                </div>

                <!-- Leaderboard -->
                <div class="glass-effect rounded-2xl p-6 mt-6">
                    <h2 class="text-xl font-bold mb-4 bg-gradient-gaming bg-clip-text text-transparent">
                        Leaderboard
                    </h2>
                    <div class="space-y-2">
                        <div class="flex items-center gap-3 p-2">
                            <div class="text-yellow-400 font-bold">1st</div>
                            <div class="flex-1">CryptoMaster</div>
                            <div class="text-sm text-gaming-accent">15,420 XP</div>
                        </div>
                        <div class="flex items-center gap-3 p-2">
                            <div class="text-gray-400 font-bold">2nd</div>
                            <div class="flex-1">BlockchainBoss</div>
                            <div class="text-sm text-gaming-accent">12,890 XP</div>
                        </div>
                        <div class="flex items-center gap-3 p-2">
                            <div class="text-orange-400 font-bold">3rd</div>
                            <div class="flex-1">DeFiDemon</div>
                            <div class="text-sm text-gaming-accent">11,240 XP</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- TradingView Modal -->
    <div id="tradingViewModal" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-background/80 backdrop-blur-md" onclick="closeTradingView()"></div>
        <div class="relative z-10 w-full h-full max-w-7xl max-h-[90vh] m-4">
            <div class="glass-effect rounded-2xl p-4 h-full flex flex-col">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-bold bg-gradient-primary bg-clip-text text-transparent">
                        üìà Advanced BTC Trading Chart
                    </h2>
                    <button onclick="closeTradingView()" class="px-4 py-2 bg-red-500 hover:bg-red-600 transition-colors rounded-lg text-white font-semibold">
                        ‚úï Close
                    </button>
                </div>
                <div class="flex-1 bg-background/50 rounded-xl overflow-hidden">
                    <div id="tradingview-widget" class="w-full h-full"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- PvP Prediction Modal -->
    <div id="pvpModal" class="hidden fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-card border border-border rounded-2xl w-full max-w-lg glass-effect animate-slide-up">
            <div class="flex justify-between items-center p-6 border-b border-border">
                <h2 class="text-2xl font-bold text-foreground">üéØ PvP BTC Prediction</h2>
                <button onclick="closePvPModal()" class="text-muted-foreground hover:text-foreground transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="p-6 space-y-6">
                <!-- Current BTC Price Display -->
                <div class="text-center p-4 bg-secondary/50 rounded-xl">
                    <div class="text-sm text-muted-foreground">Current BTC Price</div>
                    <div class="text-2xl font-bold text-gaming-primary" id="pvpCurrentPrice">$0</div>
                    <div class="text-xs text-muted-foreground">Battle ends in 4 hours</div>
                </div>

                <!-- Price Prediction Input -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-foreground">Your BTC Price Prediction (4 hours)</label>
                    <div class="relative">
                        <span class="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground">$</span>
                        <input type="number" 
                               id="predictionPrice" 
                               class="w-full pl-8 pr-4 py-3 bg-secondary border border-border rounded-lg text-foreground focus:ring-2 focus:ring-gaming-primary focus:border-transparent" 
                               placeholder="Enter your prediction"
                               min="1000"
                               max="200000"
                               step="1"
                               oninput="updatePredictionSummary()">
                    </div>
                </div>

                <!-- Direction Selection -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-foreground">Direction</label>
                    <div class="grid grid-cols-2 gap-3">
                        <button type="button" 
                                onclick="selectDirection('below')" 
                                id="belowBtn"
                                class="p-3 border border-border rounded-lg text-center hover:border-red-500 hover:bg-red-500/10 transition-all">
                            <div class="text-red-500">üìâ Below</div>
                            <div class="text-xs text-muted-foreground">Price will be lower</div>
                        </button>
                        <button type="button" 
                                onclick="selectDirection('above')" 
                                id="aboveBtn"
                                class="p-3 border border-border rounded-lg text-center hover:border-green-500 hover:bg-green-500/10 transition-all">
                            <div class="text-green-500">üìà Above</div>
                            <div class="text-xs text-muted-foreground">Price will be higher</div>
                        </button>
                    </div>
                </div>

                <!-- Bet Amount Selection -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-foreground">Bet Amount ($COIN)</label>
                    <div class="grid grid-cols-3 gap-3">
                        <button type="button" 
                                onclick="selectBetAmount(10)" 
                                id="bet10"
                                class="p-3 border border-border rounded-lg text-center hover:border-gaming-primary hover:bg-gaming-primary/10 transition-all">
                            <div class="font-bold text-gaming-primary">$10</div>
                        </button>
                        <button type="button" 
                                onclick="selectBetAmount(50)" 
                                id="bet50"
                                class="p-3 border border-border rounded-lg text-center hover:border-gaming-primary hover:bg-gaming-primary/10 transition-all">
                            <div class="font-bold text-gaming-primary">$50</div>
                        </button>
                        <button type="button" 
                                onclick="selectBetAmount(100)" 
                                id="bet100"
                                class="p-3 border border-border rounded-lg text-center hover:border-gaming-primary hover:bg-gaming-primary/10 transition-all">
                            <div class="font-bold text-gaming-primary">$100</div>
                        </button>
                    </div>
                </div>

                <!-- Prediction Summary -->
                <div id="predictionSummary" class="hidden p-4 bg-secondary/30 rounded-xl border border-gaming-primary/30">
                    <div class="text-sm text-muted-foreground mb-2">Your Prediction:</div>
                    <div id="summaryText" class="text-foreground font-medium"></div>
                </div>

                <!-- Enter Queue Button -->
                <button onclick="enterQueue()" 
                        id="enterQueueBtn"
                        disabled
                        class="w-full py-4 bg-gradient-primary hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all rounded-lg text-center text-primary-foreground font-bold text-lg">
                    üöÄ Enter Queue
                </button>
            </div>
        </div>
    </div>

    <!-- Battle Accept Modal (League of Legends Style) -->
    <div id="battleAcceptModal" class="hidden fixed inset-0 bg-black/90 backdrop-blur-sm z-60 flex items-center justify-center">
        <div class="relative">
            <!-- Circular Timer Background -->
            <div class="w-80 h-80 relative">
                <!-- Timer Circle -->
                <svg class="w-full h-full transform -rotate-90" viewBox="0 0 100 100">
                    <!-- Background Circle -->
                    <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2"/>
                    <!-- Timer Progress Circle -->
                    <circle id="timerCircle" 
                            cx="50" cy="50" r="45" 
                            fill="none" 
                            stroke="#3b82f6" 
                            stroke-width="3" 
                            stroke-linecap="round"
                            stroke-dasharray="283" 
                            stroke-dashoffset="0"
                            class="transition-all duration-1000 ease-linear"/>
                </svg>
                
                <!-- Modal Content -->
                <div class="absolute inset-0 flex items-center justify-center">
                    <div class="bg-card border-2 border-gaming-primary rounded-2xl p-6 w-64 text-center glass-effect">
                        <div class="text-2xl font-bold text-gaming-primary mb-2">‚öîÔ∏è BATTLE FOUND!</div>
                        <div id="battleTimer" class="text-3xl font-bold text-red-500 mb-4">60</div>
                        
                        <!-- Battle Info -->
                        <div class="space-y-3 mb-6">
                            <div class="bg-secondary/50 rounded-lg p-3">
                                <div class="text-sm text-muted-foreground">Your Opponent</div>
                                <div id="opponentInfo" class="font-medium text-foreground">@username</div>
                            </div>
                            <div class="bg-secondary/50 rounded-lg p-3">
                                <div class="text-sm text-muted-foreground">Battle Details</div>
                                <div id="battleDetails" class="font-medium text-foreground">$100 ‚Ä¢ 4 hours</div>
                            </div>
                        </div>
                        
                        <!-- Accept/Decline Buttons -->
                        <div class="grid grid-cols-2 gap-3">
                            <button onclick="declineBattle()" 
                                    class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white font-medium transition-colors">
                                ‚ùå Decline
                            </button>
                            <button onclick="acceptBattle()" 
                                    class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-white font-medium transition-colors">
                                ‚úÖ Accept
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sign Message Button (appears after wallet connection) -->
    <div id="signMessageContainer" class="hidden fixed bottom-6 right-6">
        <button 
            id="signMessageBtn"
            onclick="signMessage()"
            class="px-6 py-3 bg-gradient-phantom hover:opacity-90 transition-opacity rounded-lg text-white font-semibold phantom-glow animate-pulse-gaming"
        >
            Sign Message
        </button>
    </div>

    <script>
        // Global variables for BTC data
        let btcChart;
        let currentBTCPrice = 0;
        let priceHistory = [];
        let currentTimeframe = '1h';
        let tradingViewWidget = null;

        // Close welcome modal and show dashboard
        function closeWelcomeModal() {
            document.getElementById('welcomeModal').style.display = 'none';
            document.getElementById('mainDashboard').classList.remove('hidden');
            checkAuthStatus();
            checkPhantomStatus();
            initializeBTCData();
        }

        // Initialize BTC price data and chart
        async function initializeBTCData() {
            try {
                console.log('Initializing BTC data...');
                
                // Show loading
                document.getElementById('chartLoading').style.display = 'flex';
                document.getElementById('chartError').style.display = 'none';
                
                // Fetch data sequentially with error handling
                await fetchBTCPrice();
                await fetchBTCHistory();
                
                // Wait a moment for DOM to be ready
                setTimeout(() => {
                    createBTCChart();
                }, 100);
                
                // Update price every 30 seconds
                setInterval(fetchBTCPrice, 30000);
                // Update chart every 5 minutes
                setInterval(() => {
                    fetchBTCHistory();
                    updateChart();
                }, 300000);
                
                console.log('BTC data initialization complete');
            } catch (error) {
                console.error('Failed to initialize BTC data:', error);
                showChartError();
            }
        }

        // Fetch current BTC price and stats from backend
        async function fetchBTCPrice() {
            try {
                // Fetch comprehensive stats from backend
                const response = await fetch('/api/btc/stats');
                const data = await response.json();
                
                if (data.success) {
                    const price = data.current_price;
                    const change = data.change_24h;
                    const high = data.high_24h;
                    const low = data.low_24h;
                    
                    currentBTCPrice = price;
                    
                    // Update price display
                    document.getElementById('currentPrice').textContent = `$${price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    
                    // Update 24h change with color
                    const changeElement = document.getElementById('priceChange');
                    const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                    changeElement.textContent = changeText;
                    changeElement.className = `text-xl font-semibold ${change >= 0 ? 'text-green-400' : 'text-red-400'}`;
                    
                    // Update 24h high and low
                    document.getElementById('priceHigh').textContent = `$${high.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    document.getElementById('priceLow').textContent = `$${low.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    
                    // Update status indicator
                    document.getElementById('priceStatus').className = 'w-2 h-2 bg-green-400 rounded-full animate-pulse';
                    
                    console.log(`BTC Price Updated: $${price} (Source: ${data.source})`);
                } else {
                    throw new Error(data.error || 'Failed to fetch price data');
                }
            } catch (error) {
                console.error('Error fetching BTC price:', error);
                document.getElementById('priceStatus').className = 'w-2 h-2 bg-red-400 rounded-full';
                document.getElementById('currentPrice').textContent = 'Error loading';
                document.getElementById('priceChange').textContent = 'N/A';
                document.getElementById('priceHigh').textContent = 'N/A';
                document.getElementById('priceLow').textContent = 'N/A';
            }
        }

        // Fetch BTC price history for chart from backend
        async function fetchBTCHistory(timeframe = currentTimeframe) {
            try {
                const response = await fetch(`/api/btc/history?timeframe=${timeframe}`);
                const data = await response.json();
                
                if (data.success && data.data) {
                    priceHistory = data.data.map(item => ({
                        time: new Date(item.timestamp),
                        price: item.price,
                        high: item.high,
                        low: item.low,
                        volume: item.volume
                    }));
                    
                    console.log(`BTC History Updated: ${priceHistory.length} data points for ${timeframe} (Source: ${data.source})`);
                } else {
                    throw new Error(data.error || 'Failed to fetch historical data');
                }
            } catch (error) {
                console.error('Error fetching BTC history:', error);
                priceHistory = []; // Reset to empty array
                throw error; // Re-throw to be caught by calling function
            }
        }

        // Create BTC price chart
        function createBTCChart() {
            try {
                console.log('Creating BTC chart...');
                
                // Check if we have data
                if (!priceHistory || priceHistory.length === 0) {
                    console.error('No price history data available');
                    showChartError();
                    return;
                }
                
                // Get canvas element
                const canvas = document.getElementById('btcChart');
                if (!canvas) {
                    console.error('Canvas element not found');
                    showChartError();
                    return;
                }
                
                // Destroy existing chart if it exists
                if (btcChart) {
                    btcChart.destroy();
                    btcChart = null;
                }
                
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Could not get 2D context from canvas');
                    showChartError();
                    return;
                }
                
                console.log(`Creating chart with ${priceHistory.length} data points`);
            
            btcChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: priceHistory.map(p => p.time.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'})),
                    datasets: [{
                        label: 'BTC Price (USD)',
                        data: priceHistory.map(p => p.price),
                        borderColor: 'rgb(59, 130, 246)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHoverBackgroundColor: 'rgb(59, 130, 246)',
                        pointHoverBorderColor: 'white',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: 'rgb(59, 130, 246)',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return `$${context.parsed.y.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)',
                                maxTicksLimit: 6
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)',
                                callback: function(value) {
                                    return '$' + value.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0});
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    animation: {
                        duration: 750,
                        easing: 'easeInOutQuart'
                    }
                }
            });
            
            // Hide loading indicator on success
            document.getElementById('chartLoading').style.display = 'none';
            document.getElementById('chartError').style.display = 'none';
            
            console.log('BTC chart created successfully');
            
            } catch (error) {
                console.error('Error creating BTC chart:', error);
                showChartError();
            }
        }
        
        // Show chart error
        function showChartError() {
            document.getElementById('chartLoading').style.display = 'none';
            document.getElementById('chartError').style.display = 'flex';
        }
        
        // Retry chart creation
        async function retryChart() {
            console.log('Retrying chart creation...');
            document.getElementById('chartError').style.display = 'none';
            
            // Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded');
                document.getElementById('chartError').innerHTML = `
                    <div class="text-center">
                        <div class="text-red-400 mb-2">üìä Chart library not loaded</div>
                        <div class="text-sm text-muted-foreground mb-3">Refreshing page may help</div>
                        <button onclick="window.location.reload()" class="px-4 py-2 bg-gaming-primary hover:opacity-90 transition-opacity rounded-lg text-white text-sm">
                            üîÑ Refresh Page
                        </button>
                    </div>
                `;
                document.getElementById('chartError').style.display = 'flex';
                return;
            }
            
            await initializeBTCData();
        }

        // Update chart with new data
        function updateChart() {
            if (btcChart && priceHistory.length > 0) {
                // Format time labels based on timeframe
                let timeFormat;
                if (currentTimeframe === '15m' || currentTimeframe === '30m') {
                    timeFormat = { hour: '2-digit', minute: '2-digit' };
                } else {
                    timeFormat = { month: 'short', day: 'numeric', hour: '2-digit' };
                }
                
                btcChart.data.labels = priceHistory.map(p => p.time.toLocaleTimeString('en-US', timeFormat));
                btcChart.data.datasets[0].data = priceHistory.map(p => p.price);
                btcChart.update('none'); // No animation for updates
            }
        }

        // Change timeframe
        async function changeTimeframe(timeframe) {
            try {
                console.log(`Changing timeframe to: ${timeframe}`);
                currentTimeframe = timeframe;
                
                // Update button states
                document.querySelectorAll('[id^="filter-"]').forEach(btn => {
                    btn.className = 'px-3 py-1 text-xs rounded-md bg-secondary hover:bg-gaming-primary hover:text-white transition-colors';
                });
                document.getElementById(`filter-${timeframe}`).className = 'px-3 py-1 text-xs rounded-md bg-gaming-primary text-white';
                
                // Show loading
                document.getElementById('chartLoading').style.display = 'flex';
                document.getElementById('chartError').style.display = 'none';
                
                // Fetch new data and update chart
                await fetchBTCHistory(timeframe);
                
                if (priceHistory && priceHistory.length > 0) {
                    updateChart();
                    document.getElementById('chartLoading').style.display = 'none';
                } else {
                    showChartError();
                }
                
            } catch (error) {
                console.error('Error changing timeframe:', error);
                showChartError();
            }
        }

        // Open TradingView modal
        function openTradingView() {
            document.getElementById('tradingViewModal').classList.remove('hidden');
            
            // Initialize TradingView widget if not already done
            if (!tradingViewWidget) {
                initTradingViewWidget();
            }
        }

        // Close TradingView modal
        function closeTradingView() {
            document.getElementById('tradingViewModal').classList.add('hidden');
        }

        // Initialize TradingView widget
        function initTradingViewWidget() {
            const script = document.createElement('script');
            script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js';
            script.type = 'text/javascript';
            script.async = true;
            script.innerHTML = JSON.stringify({
                "autosize": true,
                "symbol": "BINANCE:BTCUSDT",
                "interval": "15",
                "timezone": "Etc/UTC",
                "theme": "dark",
                "style": "1",
                "locale": "en",
                "enable_publishing": false,
                "allow_symbol_change": true,
                "calendar": false,
                "support_host": "https://www.tradingview.com"
            });
            
            const container = document.getElementById('tradingview-widget');
            container.innerHTML = ''; // Clear existing content
            container.appendChild(script);
            
            tradingViewWidget = true;
        }

        // X OAuth Functions
        async function connectX() {
            const statusDiv = document.getElementById('status');
            statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-blue-900/20 border border-blue-500/30 text-blue-300';
            statusDiv.textContent = 'X connection initiated! Redirecting to X authentication...';
            
            try {
                const response = await fetch('/auth/x/login', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const popup = window.open(
                        data.auth_url,
                        'x_oauth',
                        'width=600,height=700,scrollbars=yes,resizable=yes'
                    );
                    
                    window.addEventListener('message', function(event) {
                        if (event.data.type === 'X_AUTH_SUCCESS') {
                            popup.close();
                            statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                            statusDiv.textContent = `X connected successfully! Welcome, ${event.data.user.name || event.data.user.username}!`;
                            
                            const xButton = document.getElementById('xConnectBtn');
                            xButton.innerHTML = `
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                                </svg>
                                ‚úì ${event.data.user.username}
                            `;
                            xButton.onclick = disconnectX;
                        }
                    });
                    
                    const checkClosed = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkClosed);
                            checkAuthStatus();
                        }
                    }, 1000);
                    
                } else {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                    statusDiv.textContent = 'Failed to initiate X authentication: ' + (data.error || 'Unknown error');
                }
                
            } catch (error) {
                console.error('X Connect error:', error);
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = 'Connection error. Please try again.';
            }
        }

        async function disconnectX() {
            const statusDiv = document.getElementById('status');
            
            try {
                const response = await fetch('/auth/logout', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                    statusDiv.textContent = 'Disconnected from X successfully!';
                    
                    const xButton = document.getElementById('xConnectBtn');
                    xButton.innerHTML = `
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                        X Connect
                    `;
                    xButton.onclick = connectX;
                }
            } catch (error) {
                console.error('Disconnect error:', error);
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = 'Failed to disconnect. Please try again.';
            }
        }

        async function checkAuthStatus() {
            try {
                const response = await fetch('/auth/status', {
                    credentials: 'include'
                });
                
                const data = await response.json();
                
                if (data.authenticated) {
                    const statusDiv = document.getElementById('status');
                    if (!statusDiv.textContent.includes('Phantom')) {
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                        statusDiv.textContent = `Already connected as ${data.user.name || data.user.username}!`;
                    }
                    
                    const xButton = document.getElementById('xConnectBtn');
                    xButton.innerHTML = `
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                        ‚úì ${data.user.username}
                    `;
                    xButton.onclick = disconnectX;
                }
            } catch (error) {
                console.error('Auth status check error:', error);
            }
        }

        // Phantom Wallet Functions
        async function connectPhantom() {
            console.log('üîµ [PHANTOM] Starting connection process...');
            const statusDiv = document.getElementById('status');
            
            // Detailed environment logging
            console.log('üîç [PHANTOM] Environment check:');
            console.log('  - window.solana exists:', !!window.solana);
            console.log('  - window.solana.isPhantom:', window.solana?.isPhantom);
            console.log('  - window.solana.isConnected:', window.solana?.isConnected);
            console.log('  - window.solana.publicKey:', window.solana?.publicKey?.toString());
            console.log('  - User Agent:', navigator.userAgent);
            console.log('  - Location:', window.location.href);
            
            // Check if Phantom is installed
            if (!window.solana) {
                console.log('‚ùå [PHANTOM] Phantom wallet not detected');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.innerHTML = `
                    <div>
                        <div>Phantom wallet not found! Please install Phantom wallet extension.</div>
                        <a href="https://phantom.app/" target="_blank" class="text-blue-400 underline hover:text-blue-300 transition-colors">
                            Click here to install Phantom wallet
                        </a>
                    </div>
                `;
                return;
            }

            console.log('‚úÖ [PHANTOM] Phantom wallet detected');

            // Wait for Phantom to be ready with more detailed logging
            let attempts = 0;
            const maxAttempts = 20; // Increased attempts
            
            console.log('‚è≥ [PHANTOM] Waiting for Phantom to be ready...');
            while (attempts < maxAttempts) {
                const isPhantom = window.solana.isPhantom;
                const hasConnect = typeof window.solana.connect === 'function';
                
                console.log(`  Attempt ${attempts + 1}/${maxAttempts}:`);
                console.log('    - isPhantom:', isPhantom);
                console.log('    - hasConnect:', hasConnect);
                console.log('    - isConnected:', window.solana.isConnected);
                
                if (isPhantom && hasConnect) {
                    console.log('‚úÖ [PHANTOM] Phantom is ready!');
                    break;
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
                attempts++;
            }
            
            if (!window.solana.isPhantom) {
                console.log('‚ùå [PHANTOM] Phantom not properly initialized after waiting');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = 'Please install the official Phantom wallet extension.';
                return;
            }
            
            try {
                console.log('üîÑ [PHANTOM] Starting connection attempt...');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-purple-900/20 border border-purple-500/30 text-purple-300';
                statusDiv.textContent = 'Connecting to Phantom wallet...';
                
                // Check if already connected
                if (window.solana.isConnected && window.solana.publicKey) {
                    console.log('‚úÖ [PHANTOM] Already connected, using existing connection');
                    console.log('  - Public Key:', window.solana.publicKey.toString());
                    const publicKey = window.solana.publicKey.toString();
                    await handlePhantomConnection(publicKey, statusDiv);
                    return;
                }
                
                console.log('üîó [PHANTOM] Attempting new connection...');
                
                // Try multiple connection methods in order of compatibility
                let response;
                const connectionMethods = [
                    { name: 'Legacy Basic connect()', fn: () => window.solana.connect() },
                    { name: 'Modern connect({ onlyIfTrusted: false })', fn: () => window.solana.connect({ onlyIfTrusted: false }) },
                    { name: 'Trusted connect({ onlyIfTrusted: true })', fn: () => window.solana.connect({ onlyIfTrusted: true }) },
                    { name: 'Request method', fn: () => window.solana.request({ method: 'connect' }) },
                    { name: 'Direct enable', fn: () => window.solana.enable ? window.solana.enable() : Promise.reject(new Error('enable not available')) }
                ];
                
                let lastError = null;
                let methodIndex = 0;
                
                for (const method of connectionMethods) {
                    try {
                        console.log(`  Method ${methodIndex + 1}: ${method.name}`);
                        response = await method.fn();
                        console.log(`‚úÖ [PHANTOM] ${method.name} succeeded`);
                        console.log('  Response:', response);
                        break;
                    } catch (error) {
                        console.log(`‚ùå [PHANTOM] ${method.name} failed:`, error);
                        console.log('  Error details:');
                        console.log('    - code:', error.code);
                        console.log('    - message:', error.message);
                        console.log('    - name:', error.name);
                        lastError = error;
                        methodIndex++;
                    }
                }
                
                if (!response) {
                    console.log('‚ùå [PHANTOM] All connection methods failed');
                    console.log('  Available methods on window.solana:', Object.keys(window.solana).filter(key => typeof window.solana[key] === 'function'));
                    throw lastError || new Error('All connection methods failed');
                }
                
                console.log('üîç [PHANTOM] Connection response:', response);
                
                if (!response) {
                    console.log('‚ùå [PHANTOM] No response from connection attempt');
                    throw new Error('No response received from Phantom');
                }
                
                if (!response.publicKey) {
                    console.log('‚ùå [PHANTOM] No public key in response');
                    console.log('  Response keys:', Object.keys(response));
                    throw new Error('No public key received from Phantom');
                }
                
                const publicKey = response.publicKey.toString();
                console.log('‚úÖ [PHANTOM] Got public key:', publicKey);
                
                await handlePhantomConnection(publicKey, statusDiv);
                
            } catch (error) {
                console.log('‚ùå [PHANTOM] Connection failed with error:', error);
                console.log('  Error type:', typeof error);
                console.log('  Error constructor:', error.constructor.name);
                console.log('  Error code:', error.code);
                console.log('  Error message:', error.message);
                console.log('  Error stack:', error.stack);
                console.log('  Error keys:', Object.keys(error));
                
                // Log the full error object
                try {
                    console.log('  Error JSON:', JSON.stringify(error, null, 2));
                } catch (jsonError) {
                    console.log('  Could not stringify error:', jsonError.message);
                }
                
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                
                // Handle specific error codes with detailed logging
                if (error.code === 4001 || error.message?.includes('User rejected')) {
                    console.log('üö´ [PHANTOM] User rejected connection');
                    statusDiv.textContent = '‚ùå Connection rejected by user. Please try again.';
                } else if (error.code === -32002 || error.message?.includes('already pending')) {
                    console.log('‚è≥ [PHANTOM] Connection already pending');
                    statusDiv.textContent = '‚è≥ Connection request already pending. Check your Phantom wallet.';
                } else if (error.message?.includes('Unexpected error')) {
                    console.log('‚ùó [PHANTOM] Unexpected error from Phantom extension');
                    statusDiv.textContent = 'üîÑ Phantom connection issue. Please refresh the page and try again.';
                } else if (error.message?.includes('not available')) {
                    console.log('‚ùå [PHANTOM] Connection method not available');
                    statusDiv.textContent = '‚ö†Ô∏è Phantom wallet not properly installed. Please reinstall Phantom.';
                } else {
                    console.log('‚ùå [PHANTOM] Generic connection error');
                    statusDiv.textContent = `‚ùå Connection failed: ${error.message || 'Please try again'}`;
                }
                
                // Add detailed error info for debugging
                statusDiv.innerHTML += `<div style="font-size: 0.8em; margin-top: 8px; opacity: 0.7;">Debug: ${error.constructor.name} - ${error.message}</div>`;
                
                // Add retry button for certain errors
                if (error.code !== 4001) {
                    setTimeout(() => {
                        const retryButton = document.createElement('button');
                        retryButton.textContent = 'üîÑ Retry Connection';
                        retryButton.className = 'mt-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded text-white transition-colors';
                        retryButton.onclick = connectPhantom;
                        statusDiv.appendChild(retryButton);
                    }, 2000);
                }
            }
        }

        // Helper function to handle the actual connection process
        async function handlePhantomConnection(publicKey, statusDiv) {
            console.log('üîó [PHANTOM] Processing connection for public key:', publicKey);
            
            try {
                console.log('üì° [PHANTOM] Sending to backend...');
                const backendResponse = await fetch('/auth/phantom/connect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        publicKey: publicKey
                    })
                });
                
                console.log('üì° [PHANTOM] Backend response status:', backendResponse.status);
                console.log('üì° [PHANTOM] Backend response headers:', [...backendResponse.headers.entries()]);
                
                const data = await backendResponse.json();
                console.log('üì° [PHANTOM] Backend response data:', data);
                
                if (data.success) {
                    console.log('‚úÖ [PHANTOM] Backend connection successful');
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                    const shortKey = publicKey.substring(0, 4) + '...' + publicKey.substring(publicKey.length - 4);
                    statusDiv.textContent = `‚úÖ Phantom wallet connected! ${shortKey}`;
                    
                    const phantomButton = document.getElementById('phantomConnectBtn');
                    phantomButton.innerHTML = `
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                        </svg>
                        ‚úì ${shortKey}
                    `;
                    phantomButton.onclick = disconnectPhantom;
                    
                    document.getElementById('signMessageContainer').classList.remove('hidden');
                    
                } else {
                    console.log('‚ùå [PHANTOM] Backend returned error:', data.error);
                    throw new Error(data.error || 'Backend connection failed');
                }
                
            } catch (backendError) {
                console.log('‚ùå [PHANTOM] Backend connection error:', backendError);
                console.log('  Backend error type:', typeof backendError);
                console.log('  Backend error message:', backendError.message);
                console.log('  Backend error stack:', backendError.stack);
                
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = `‚ùå Failed to register wallet: ${backendError.message}`;
            }
        }

        async function disconnectPhantom() {
            const statusDiv = document.getElementById('status');
            
            try {
                if (window.solana && window.solana.disconnect) {
                    await window.solana.disconnect();
                }
                
                const response = await fetch('/auth/phantom/disconnect', {
                    method: 'POST',
                    credentials: 'include'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                    statusDiv.textContent = 'Phantom wallet disconnected successfully!';
                    
                    const phantomButton = document.getElementById('phantomConnectBtn');
                    phantomButton.innerHTML = `
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                        </svg>
                        Phantom Wallet
                    `;
                    phantomButton.onclick = connectPhantom;
                    
                    document.getElementById('signMessageContainer').classList.add('hidden');
                }
                
            } catch (error) {
                console.error('Disconnect error:', error);
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = 'Failed to disconnect. Please try again.';
            }
        }

        async function signMessage() {
            const statusDiv = document.getElementById('status');
            
            try {
                const message = `Sign this message to verify your wallet ownership.\nTimestamp: ${new Date().toISOString()}`;
                const encodedMessage = new TextEncoder().encode(message);
                
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-purple-900/20 border border-purple-500/30 text-purple-300';
                statusDiv.textContent = 'Please sign the message in your Phantom wallet...';
                
                const signedMessage = await window.solana.signMessage(encodedMessage, 'utf8');
                
                const response = await fetch('/auth/phantom/sign', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        message: message,
                        signature: Array.from(signedMessage.signature),
                        publicKey: signedMessage.publicKey.toString()
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                    statusDiv.textContent = 'Message signed successfully! ‚úì Wallet verified';
                } else {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                    statusDiv.textContent = 'Failed to verify signature: ' + (data.error || 'Unknown error');
                }
                
            } catch (error) {
                console.error('Message signing error:', error);
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                
                if (error.code === 4001) {
                    statusDiv.textContent = 'Message signing rejected by user.';
                } else {
                    statusDiv.textContent = 'Failed to sign message. Please try again.';
                }
            }
        }

        async function checkPhantomStatus() {
            try {
                const response = await fetch('/auth/phantom/status', {
                    credentials: 'include'
                });
                
                const data = await response.json();
                
                if (data.connected) {
                    const statusDiv = document.getElementById('status');
                    const shortKey = data.publicKey.substring(0, 4) + '...' + data.publicKey.substring(data.publicKey.length - 4);
                    
                    if (!statusDiv.textContent.includes('X connected') && !statusDiv.textContent.includes('Phantom')) {
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                        statusDiv.textContent = `Phantom wallet already connected! ${shortKey}`;
                    }
                    
                    const phantomButton = document.getElementById('phantomConnectBtn');
                    phantomButton.innerHTML = `
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                        </svg>
                        ‚úì ${shortKey}
                    `;
                    phantomButton.onclick = disconnectPhantom;
                    
                    document.getElementById('signMessageContainer').classList.remove('hidden');
                }
            } catch (error) {
                console.error('Phantom status check error:', error);
            }
        }

        // Game Mode Functions
        function startGame(gameMode) {
            if (gameMode === 'PVP Ranked') {
                // Open PvP prediction modal
                openPvPModal();
                return;
            }
            
            const statusDiv = document.getElementById('status');
            statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-blue-900/20 border border-blue-500/30 text-blue-300';
            
            // Show current BTC price in the message
            const priceText = currentBTCPrice > 0 ? ` Current BTC: $${currentBTCPrice.toLocaleString('en-US', {maximumFractionDigits: 2})}` : '';
            statusDiv.textContent = `Starting ${gameMode}...${priceText} Please connect your wallet and X account to continue!`;
            
            // Check if user has authentication
            checkAuthenticationForGame(gameMode);
        }

        async function checkAuthenticationForGame(gameMode) {
            try {
                // Check X auth
                const xResponse = await fetch('/auth/status', { credentials: 'include' });
                const xData = await xResponse.json();
                
                // Check Phantom auth
                const phantomResponse = await fetch('/auth/phantom/status', { credentials: 'include' });
                const phantomData = await phantomResponse.json();
                
                const statusDiv = document.getElementById('status');
                
                if (xData.authenticated && phantomData.connected) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                    const priceText = currentBTCPrice > 0 ? ` BTC: $${currentBTCPrice.toLocaleString('en-US', {maximumFractionDigits: 2})}` : '';
                    statusDiv.textContent = `üéÆ Ready to play ${gameMode}! All authentication complete.${priceText}`;
                    
                    // Here you would normally start the actual game
                    setTimeout(() => {
                        statusDiv.textContent = `üöÄ Launching ${gameMode} with live BTC data... (Game functionality coming soon!)`;
                    }, 2000);
                    
                } else if (!xData.authenticated && !phantomData.connected) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-orange-900/20 border border-orange-500/30 text-orange-300';
                    statusDiv.textContent = '‚ö†Ô∏è Please connect both X account and Phantom wallet to play!';
                } else if (!xData.authenticated) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-orange-900/20 border border-orange-500/30 text-orange-300';
                    statusDiv.textContent = '‚ö†Ô∏è Please connect your X account to continue!';
                } else if (!phantomData.connected) {
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-orange-900/20 border border-orange-500/30 text-orange-300';
                    statusDiv.textContent = '‚ö†Ô∏è Please connect your Phantom wallet to continue!';
                }
                
            } catch (error) {
                console.error('Auth check error:', error);
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = 'Error checking authentication. Please try again.';
            }
        }

        // PvP System Variables
        let pvpPrediction = {
            price: 0,
            direction: '',
            betAmount: 0
        };
        let userQueue = [];
        let activeBattles = [];
        let battleAcceptTimer = null;
        let currentBattleMatch = null;
        
        // Database and Authentication Variables
        let pvpDB = null;
        let currentUser = null;

        // PvP Modal Functions
        async function openPvPModal() {
            // Check authentication before opening modal
            try {
                const xResponse = await fetch('/auth/status', { credentials: 'include' });
                const xData = await xResponse.json();
                
                const phantomResponse = await fetch('/auth/phantom/status', { credentials: 'include' });
                const phantomData = await phantomResponse.json();
                
                if (!xData.authenticated || !phantomData.connected) {
                    const statusDiv = document.getElementById('status');
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-orange-900/20 border border-orange-500/30 text-orange-300';
                    statusDiv.textContent = '‚ö†Ô∏è PvP Ranked requires authentication! Please connect both X account and Phantom wallet.';
                    return;
                }
            } catch (error) {
                console.error('Auth check error:', error);
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = '‚ùå Authentication check failed. Please try again.';
                return;
            }
            
            document.getElementById('pvpModal').classList.remove('hidden');
            // Update current BTC price in modal
            document.getElementById('pvpCurrentPrice').textContent = 
                currentBTCPrice > 0 ? `$${currentBTCPrice.toLocaleString('en-US', {maximumFractionDigits: 2})}` : '$0';
            
            // Set default prediction price to current price
            if (currentBTCPrice > 0) {
                document.getElementById('predictionPrice').value = Math.round(currentBTCPrice);
            }
            
            // Reset form
            resetPvPForm();
        }

        function closePvPModal() {
            document.getElementById('pvpModal').classList.add('hidden');
            resetPvPForm();
        }

        function resetPvPForm() {
            pvpPrediction = { price: 0, direction: '', betAmount: 0 };
            
            // Reset direction buttons
            document.getElementById('belowBtn').classList.remove('border-red-500', 'bg-red-500/20');
            document.getElementById('aboveBtn').classList.remove('border-green-500', 'bg-green-500/20');
            
            // Reset bet amount buttons
            ['bet10', 'bet50', 'bet100'].forEach(id => {
                document.getElementById(id).classList.remove('border-gaming-primary', 'bg-gaming-primary/20');
            });
            
            // Hide summary and disable button
            document.getElementById('predictionSummary').classList.add('hidden');
            document.getElementById('enterQueueBtn').disabled = true;
        }

        function selectDirection(direction) {
            pvpPrediction.direction = direction;
            
            // Reset both buttons
            document.getElementById('belowBtn').classList.remove('border-red-500', 'bg-red-500/20');
            document.getElementById('aboveBtn').classList.remove('border-green-500', 'bg-green-500/20');
            
            // Highlight selected button
            if (direction === 'below') {
                document.getElementById('belowBtn').classList.add('border-red-500', 'bg-red-500/20');
            } else {
                document.getElementById('aboveBtn').classList.add('border-green-500', 'bg-green-500/20');
            }
            
            updatePredictionSummary();
        }

        function selectBetAmount(amount) {
            pvpPrediction.betAmount = amount;
            
            // Reset all bet buttons
            ['bet10', 'bet50', 'bet100'].forEach(id => {
                document.getElementById(id).classList.remove('border-gaming-primary', 'bg-gaming-primary/20');
            });
            
            // Highlight selected button
            document.getElementById(`bet${amount}`).classList.add('border-gaming-primary', 'bg-gaming-primary/20');
            
            updatePredictionSummary();
        }

        function updatePredictionSummary() {
            const price = parseFloat(document.getElementById('predictionPrice').value) || 0;
            pvpPrediction.price = price;
            
            if (price > 0 && pvpPrediction.direction && pvpPrediction.betAmount > 0) {
                const directionText = pvpPrediction.direction === 'below' ? 'üìâ Below' : 'üìà Above';
                const summaryText = `BTC ${directionText} $${price.toLocaleString()} for $${pvpPrediction.betAmount}`;
                
                document.getElementById('summaryText').textContent = summaryText;
                document.getElementById('predictionSummary').classList.remove('hidden');
                document.getElementById('enterQueueBtn').disabled = false;
            } else {
                document.getElementById('predictionSummary').classList.add('hidden');
                document.getElementById('enterQueueBtn').disabled = true;
            }
        }

        async function enterQueue() {
            if (!pvpPrediction.price || !pvpPrediction.direction || !pvpPrediction.betAmount) {
                alert('Please complete all fields');
                return;
            }
            
            // Verify user is fully authenticated before entering queue
            try {
                const xResponse = await fetch('/auth/status', { credentials: 'include' });
                const xData = await xResponse.json();
                
                const phantomResponse = await fetch('/auth/phantom/status', { credentials: 'include' });
                const phantomData = await phantomResponse.json();
                
                if (!xData.authenticated || !phantomData.connected) {
                    alert('‚ùå Authentication required! Please connect both your X account and Phantom wallet before entering PvP queue.');
                    return;
                }
                
                // Update current user info
                currentUser = xData.user;
                
                // Ensure PvPDatabase has the current user
                if (pvpDB) {
                    pvpDB.currentUser = currentUser;
                    console.log('üîó [QUEUE_ENTRY] Updated currentUser in PvPDatabase:', currentUser);
                }
                
            } catch (error) {
                console.error('Authentication check failed:', error);
                alert('‚ùå Failed to verify authentication. Please try again.');
                return;
            }
            
            // Create queue entry
            const queueEntry = {
                id: Date.now(),
                price: pvpPrediction.price,
                direction: pvpPrediction.direction,
                betAmount: pvpPrediction.betAmount,
                timestamp: Date.now(),
                status: 'searching'
            };
            
            userQueue.push(queueEntry);
            updateQueueDisplay();
            closePvPModal();
            
            // Show success message
            const statusDiv = document.getElementById('status');
            statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
            statusDiv.textContent = `üéØ Entered queue! Searching for opponent with ${pvpPrediction.direction === 'below' ? 'above' : 'below'} prediction...`;
            
            // Start real matchmaking with database
            startRealMatchmaking(queueEntry);
        }

        async function startRealMatchmaking(queueEntry) {
            try {
                // Check authentication first
                if (!currentUser || !pvpDB) {
                    const statusDiv = document.getElementById('status');
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                    statusDiv.textContent = '‚ö†Ô∏è Authentication required. Please connect both X account and Phantom wallet.';
                    return;
                }

                // Create prediction in database
                console.log('üîç [MATCHMAKING] Current user data:', currentUser);
                console.log('üîç [MATCHMAKING] PvP DB current user:', pvpDB.currentUser);
                
                if (!currentUser || !currentUser.id) {
                    throw new Error('Current user or user ID is missing');
                }
                
                const predictionData = {
                    user_id: currentUser.id,
                    predicted_price: queueEntry.price,
                    direction: queueEntry.direction,
                    bet_amount: queueEntry.betAmount,
                    current_btc_price: currentBTCPrice
                };
                
                console.log('üìù [MATCHMAKING] Creating prediction with data:', predictionData);
                
                // Use backend API to create prediction (bypasses RLS)
                const predictionResponse = await fetch('/api/predictions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify(predictionData)
                });
                
                const predictionResult = await predictionResponse.json();
                console.log('üìù [MATCHMAKING] Prediction API response:', predictionResult);
                
                if (!predictionResult.success) {
                    throw new Error(predictionResult.error || 'Failed to create prediction');
                }
                
                const prediction = predictionResult.prediction;
                queueEntry.predictionId = prediction.id;
                
                // Try to find a match immediately using backend API
                const matchResponse = await fetch('/api/matchmaking/find', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        prediction_id: prediction.id
                    })
                });
                
                const matchResult = await matchResponse.json();
                console.log('üîç [MATCHMAKING] Match search result:', matchResult);
                
                if (!matchResult.success) {
                    throw new Error(matchResult.error || 'Failed to search for match');
                }
                
                const battleId = matchResult.match_found ? matchResult.battle_id : null;
                
                if (battleId) {
                    // Match found! Get battle details using backend API
                    const battleResponse = await fetch(`/api/battles/${battleId}`, {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    const battleResult = await battleResponse.json();
                    console.log('‚öîÔ∏è [MATCHMAKING] Battle details:', battleResult);
                    
                    if (!battleResult.success) {
                        throw new Error(battleResult.error || 'Failed to get battle details');
                    }
                    
                    handleMatchFound(queueEntry, battleResult.battle);
                } else {
                    // No immediate match found, check for existing pending battles first
                    const pendingResponse = await fetch('/api/battles/pending', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    const pendingResult = await pendingResponse.json();
                    console.log('üîç [MATCHMAKING] Initial pending battles check:', pendingResult);
                    
                    if (pendingResult.success && pendingResult.count > 0) {
                        // User has pending battle invitations!
                        const battle = pendingResult.pending_battles[0];
                        console.log('üîî [MATCHMAKING] Found existing pending battle:', battle.id);
                        handleMatchFound(queueEntry, battle);
                    } else {
                        // No pending battles, start searching
                        const statusDiv = document.getElementById('status');
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-blue-900/20 border border-blue-500/30 text-blue-300';
                        statusDiv.textContent = `üîç Searching for real opponents... You'll be matched with another player soon.`;
                        
                        // Start polling for matches
                        startMatchPolling(queueEntry);
                    }
                }
                
            } catch (error) {
                console.error('Matchmaking error:', error);
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = '‚ùå Matchmaking failed. Please try again.';
            }
        }

        async function startMatchPolling(queueEntry) {
            const pollInterval = setInterval(async () => {
                try {
                    // Check if still in queue
                    if (!userQueue.find(q => q.id === queueEntry.id)) {
                        clearInterval(pollInterval);
                        return;
                    }
                    
                    // First, check for pending battle invitations
                    const pendingResponse = await fetch('/api/battles/pending', {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    const pendingResult = await pendingResponse.json();
                    console.log('üîÑ [POLLING] Pending battles check:', pendingResult);
                    
                    if (pendingResult.success && pendingResult.count > 0) {
                        // Found a pending battle invitation!
                        clearInterval(pollInterval);
                        const battle = pendingResult.pending_battles[0]; // Take the first one
                        console.log('üîî [POLLING] Found pending battle invitation:', battle.id);
                        handleMatchFound(queueEntry, battle);
                        return;
                    }
                    
                    // If no pending battles, try to find a new match
                    const matchResponse = await fetch('/api/matchmaking/find', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify({
                            prediction_id: queueEntry.predictionId
                        })
                    });
                    
                    const matchResult = await matchResponse.json();
                    console.log('üîÑ [POLLING] New match check result:', matchResult);
                    
                    if (matchResult.success && matchResult.match_found) {
                        clearInterval(pollInterval);
                        
                        const battleResponse = await fetch(`/api/battles/${matchResult.battle_id}`, {
                            method: 'GET',
                            credentials: 'include'
                        });
                        
                        const battleResult = await battleResponse.json();
                        
                        if (battleResult.success) {
                            handleMatchFound(queueEntry, battleResult.battle);
                        }
                    }
                } catch (error) {
                    console.error('Match polling error:', error);
                    clearInterval(pollInterval);
                }
            }, 5000); // Poll every 5 seconds (increased frequency for better responsiveness)
        }

        async function handleMatchFound(queueEntry, battle) {
            // Get opponent details from battle
            const isUser1 = battle.user1_id === currentUser.id;
            const opponentId = isUser1 ? battle.user2_id : battle.user1_id;
            const opponentUser = isUser1 ? battle.user2 : battle.user1;
            const opponentPrediction = isUser1 ? battle.user2_prediction : battle.user1_prediction;
            
            const opponent = {
                id: opponentId,
                username: opponentUser?.username || 'Anonymous',
                price: opponentPrediction.predicted_price,
                direction: opponentPrediction.direction,
                betAmount: opponentPrediction.bet_amount
            };
            
            currentBattleMatch = {
                user: queueEntry,
                opponent: opponent,
                potSize: battle.pot_size,
                battleId: battle.id
            };
            
            showBattleAcceptModal();
        }

        function showBattleAcceptModal() {
            document.getElementById('battleAcceptModal').classList.remove('hidden');
            
            // Update battle info
            document.getElementById('opponentInfo').textContent = `@${currentBattleMatch.opponent.username}`;
            document.getElementById('battleDetails').textContent = 
                `$${currentBattleMatch.potSize} pot ‚Ä¢ 4 hours`;
            
            // Start 60-second timer
            let timeLeft = 60;
            document.getElementById('battleTimer').textContent = timeLeft;
            
            // Play battle found sound (if audio is enabled)
            playBattleFoundSound();
            
            battleAcceptTimer = setInterval(() => {
                timeLeft--;
                document.getElementById('battleTimer').textContent = timeLeft;
                
                // Update timer circle
                const circumference = 283; // 2 * œÄ * 45
                const offset = circumference - (timeLeft / 60) * circumference;
                document.getElementById('timerCircle').style.strokeDashoffset = offset;
                
                if (timeLeft <= 0) {
                    clearInterval(battleAcceptTimer);
                    declineBattle(); // Auto-decline if time runs out
                }
            }, 1000);
        }

        async function acceptBattle() {
            try {
                clearInterval(battleAcceptTimer);
                
                // Show loading state
                const acceptBtn = document.querySelector('button[onclick="acceptBattle()"]');
                const declineBtn = document.querySelector('button[onclick="declineBattle()"]');
                acceptBtn.disabled = true;
                declineBtn.disabled = true;
                acceptBtn.innerHTML = '‚è≥ Accepting...';
                
                console.log('üî• [BATTLE_ACCEPT] Accepting battle:', currentBattleMatch.battleId);
                
                // Call backend API to accept battle
                const response = await fetch(`/api/battles/${currentBattleMatch.battleId}/accept`, {
                    method: 'POST',
                    credentials: 'include'
                });
                
                const result = await response.json();
                console.log('üî• [BATTLE_ACCEPT] Accept result:', result);
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to accept battle');
                }
                
                document.getElementById('battleAcceptModal').classList.add('hidden');
                
                // Remove from queue
                userQueue = userQueue.filter(q => q.id !== currentBattleMatch.user.id);
                updateQueueDisplay();
                
                const statusDiv = document.getElementById('status');
                
                if (result.both_accepted) {
                    // Both users accepted - battle is now active!
                    const battle = {
                        id: currentBattleMatch.battleId,
                        user: currentBattleMatch.user,
                        opponent: currentBattleMatch.opponent,
                        potSize: currentBattleMatch.potSize,
                        startTime: Date.now(),
                        endTime: Date.now() + (4 * 60 * 60 * 1000), // 4 hours
                        status: 'active'
                    };
                    
                    activeBattles.push(battle);
                    
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                    statusDiv.textContent = `üéâ Battle started! Both players accepted. $${battle.potSize} pot ‚Ä¢ Ends in 4 hours`;
                    
                    console.log('üéâ [BATTLE_ACCEPT] Battle is now active - both users accepted!');
                } else {
                    // You accepted, waiting for opponent
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-blue-900/20 border border-blue-500/30 text-blue-300';
                    statusDiv.textContent = `‚úÖ You accepted the battle! Waiting for opponent to accept...`;
                    
                    console.log('‚è≥ [BATTLE_ACCEPT] Waiting for opponent to accept...');
                    
                    // Start polling for opponent acceptance
                    startOpponentAcceptancePolling(currentBattleMatch.battleId);
                }
                
                currentBattleMatch = null;
                
            } catch (error) {
                console.error('‚ùå [BATTLE_ACCEPT] Error accepting battle:', error);
                
                // Re-enable buttons
                const acceptBtn = document.querySelector('button[onclick="acceptBattle()"]');
                const declineBtn = document.querySelector('button[onclick="declineBattle()"]');
                acceptBtn.disabled = false;
                declineBtn.disabled = false;
                acceptBtn.innerHTML = '‚úÖ Accept';
                
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = `‚ùå Failed to accept battle: ${error.message}`;
            }
        }

        async function declineBattle() {
            try {
                clearInterval(battleAcceptTimer);
                
                // Show loading state
                const acceptBtn = document.querySelector('button[onclick="acceptBattle()"]');
                const declineBtn = document.querySelector('button[onclick="declineBattle()"]');
                acceptBtn.disabled = true;
                declineBtn.disabled = true;
                declineBtn.innerHTML = '‚è≥ Declining...';
                
                console.log('‚ùå [BATTLE_DECLINE] Declining battle:', currentBattleMatch.battleId);
                
                // Call backend API to decline battle
                const response = await fetch(`/api/battles/${currentBattleMatch.battleId}/decline`, {
                    method: 'POST',
                    credentials: 'include'
                });
                
                const result = await response.json();
                console.log('‚ùå [BATTLE_DECLINE] Decline result:', result);
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to decline battle');
                }
                
                document.getElementById('battleAcceptModal').classList.add('hidden');
                currentBattleMatch = null;
                
                // Show message
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-yellow-900/20 border border-yellow-500/30 text-yellow-300';
                statusDiv.textContent = '‚ùå Battle declined. Your prediction is back in the queue searching for opponents...';
                
                console.log('‚ùå [BATTLE_DECLINE] Battle declined and predictions reset to searching');
                
            } catch (error) {
                console.error('‚ùå [BATTLE_DECLINE] Error declining battle:', error);
                
                // Re-enable buttons
                const acceptBtn = document.querySelector('button[onclick="acceptBattle()"]');
                const declineBtn = document.querySelector('button[onclick="declineBattle()"]');
                acceptBtn.disabled = false;
                declineBtn.disabled = false;
                declineBtn.innerHTML = '‚ùå Decline';
                
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = `‚ùå Failed to decline battle: ${error.message}`;
            }
        }

        function startOpponentAcceptancePolling(battleId) {
            console.log('‚è≥ [OPPONENT_POLLING] Starting polling for battle:', battleId);
            
            let pollCount = 0;
            const maxPolls = 60; // Poll for 60 seconds (60 * 1 second intervals)
            
            const pollInterval = setInterval(async () => {
                try {
                    pollCount++;
                    console.log(`üîÑ [OPPONENT_POLLING] Poll ${pollCount}/${maxPolls} for battle ${battleId}`);
                    
                    const response = await fetch(`/api/battles/${battleId}`, {
                        method: 'GET',
                        credentials: 'include'
                    });
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        console.error('‚ùå [OPPONENT_POLLING] Status check failed:', result.error);
                        clearInterval(pollInterval);
                        return;
                    }
                    
                    const battle = result.battle;
                    
                    if (battle.user1_accepted && battle.user2_accepted && battle.status === 'active') {
                        // Both users accepted - battle is active!
                        clearInterval(pollInterval);
                        
                        console.log('üéâ [OPPONENT_POLLING] Both users accepted! Battle is now active');
                        
                        const statusDiv = document.getElementById('status');
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                        statusDiv.textContent = `üéâ Battle started! Your opponent also accepted. $${battle.pot_size} pot ‚Ä¢ Ends in 4 hours`;
                        
                        // Add to active battles (if not already there)
                        if (!activeBattles.find(b => b.id === battleId)) {
                            // Get opponent details from battle
                            console.log('üîç [OPPONENT_POLLING] Battle data:', battle);
                            const isUser1 = battle.user1_id === currentUser.id;
                            const opponentUser = isUser1 ? battle.user2 : battle.user1;
                            const userPrediction = isUser1 ? battle.user1_prediction : battle.user2_prediction;
                            const opponentPrediction = isUser1 ? battle.user2_prediction : battle.user1_prediction;
                            console.log('üîç [OPPONENT_POLLING] User prediction:', userPrediction);
                            console.log('üîç [OPPONENT_POLLING] Opponent prediction:', opponentPrediction);
                            
                            const activeBattle = {
                                id: battleId,
                                user: {
                                    username: currentUser.username,
                                    price: userPrediction?.predicted_price || 0,
                                    direction: userPrediction?.direction || 'above',
                                    betAmount: userPrediction?.bet_amount || 0
                                },
                                opponent: {
                                    username: opponentUser?.username || opponentUser?.x_username || 'Anonymous',
                                    price: opponentPrediction?.predicted_price || 0,
                                    direction: opponentPrediction?.direction || 'below',
                                    betAmount: opponentPrediction?.bet_amount || 0
                                },
                                potSize: battle.pot_size || 0,
                                startTime: Date.now(),
                                endTime: Date.now() + (4 * 60 * 60 * 1000),
                                status: 'active'
                            };
                            
                            activeBattles.push(activeBattle);
                            updateQueueDisplay();
                        }
                        
                    } else if (battle.status === 'cancelled') {
                        // Opponent declined
                        clearInterval(pollInterval);
                        
                        console.log('‚ùå [OPPONENT_POLLING] Opponent declined the battle');
                        
                        const statusDiv = document.getElementById('status');
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-orange-900/20 border border-orange-500/30 text-orange-300';
                        statusDiv.textContent = 'üòû Your opponent declined the battle. Searching for new opponents...';
                        
                    } else if (pollCount >= maxPolls) {
                        // Timeout - opponent didn't respond
                        clearInterval(pollInterval);
                        
                        console.log('‚è∞ [OPPONENT_POLLING] Timeout - opponent did not respond');
                        
                        const statusDiv = document.getElementById('status');
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-gray-900/20 border border-gray-500/30 text-gray-300';
                        statusDiv.textContent = '‚è∞ Battle invitation expired. Your opponent did not respond in time.';
                    }
                    
                } catch (error) {
                    console.error('‚ùå [OPPONENT_POLLING] Error:', error);
                    clearInterval(pollInterval);
                    
                    const statusDiv = document.getElementById('status');
                    statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                    statusDiv.textContent = '‚ùå Error checking battle status. Please try again.';
                }
            }, 1000); // Poll every second
        }

        function updateQueueDisplay() {
            const queueList = document.getElementById('queueList');
            const emptyQueue = document.getElementById('emptyQueue');
            const activeBattlesList = document.getElementById('activeBattlesList');
            const emptyBattles = document.getElementById('emptyBattles');
            
            // Update queue
            if (userQueue.length === 0) {
                queueList.innerHTML = '';
                emptyQueue.style.display = 'block';
            } else {
                emptyQueue.style.display = 'none';
                queueList.innerHTML = userQueue.map(entry => `
                    <div class="bg-secondary/50 rounded-lg p-4 border border-gaming-secondary/30">
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-medium text-foreground">
                                    ${entry.direction === 'below' ? 'üìâ' : 'üìà'} BTC ${entry.direction} $${entry.price.toLocaleString()}
                                </div>
                                <div class="text-sm text-muted-foreground">
                                    $${entry.betAmount} bet ‚Ä¢ ${getTimeInQueue(entry.timestamp)}
                                </div>
                            </div>
                            <button onclick="exitQueue(${entry.id})" 
                                    class="px-3 py-1 bg-red-600/20 hover:bg-red-600/30 border border-red-500/30 rounded text-red-400 text-sm transition-colors">
                                Exit Queue
                            </button>
                        </div>
                    </div>
                `).join('');
            }
            
            // Update active battles
            if (activeBattles.length === 0) {
                activeBattlesList.innerHTML = '';
                emptyBattles.style.display = 'block';
            } else {
                emptyBattles.style.display = 'none';
                activeBattlesList.innerHTML = activeBattles.filter(battle => {
                    // Filter out malformed battle objects
                    return battle && battle.opponent && battle.user && battle.opponent.username && battle.user.direction;
                }).map(battle => `
                    <div class="bg-gaming-primary/10 rounded-lg p-4 border border-gaming-primary/30">
                        <div class="flex justify-between items-center mb-2">
                            <div class="font-medium text-gaming-primary">‚öîÔ∏è vs @${battle.opponent.username}</div>
                            <div class="text-sm text-gaming-primary font-bold">$${battle.potSize || 0} pot</div>
                        </div>
                        <div class="text-sm text-muted-foreground mb-2">
                            You: ${battle.user.direction === 'below' ? 'üìâ' : 'üìà'} $${(battle.user.price || 0).toLocaleString()} ‚Ä¢ 
                            Opponent: ${battle.opponent.direction === 'below' ? 'üìâ' : 'üìà'} $${(battle.opponent.price || 0).toLocaleString()}
                        </div>
                        <div class="text-xs text-gaming-secondary">
                            ‚è∞ ${getTimeRemaining(battle.endTime)}
                        </div>
                    </div>
                `).join('');
            }
        }

        async function exitQueue(queueId) {
            try {
                if (currentUser) {
                    // Use backend API to cancel prediction
                    const cancelResponse = await fetch(`/api/predictions/${queueId}/cancel`, {
                        method: 'POST',
                        credentials: 'include'
                    });
                    
                    const cancelResult = await cancelResponse.json();
                    console.log('‚ùå [QUEUE_EXIT] Cancel result:', cancelResult);
                    
                    if (!cancelResult.success) {
                        console.error('Failed to cancel prediction:', cancelResult.error);
                    }
                    
                    // Refresh user data
                    await loadUserData();
                    updateQueueDisplay();
                } else {
                    // Fallback to local
                    userQueue = userQueue.filter(q => q.id !== queueId);
                    updateQueueDisplay();
                }
                
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-yellow-900/20 border border-yellow-500/30 text-yellow-300';
                statusDiv.textContent = 'üö™ Exited queue successfully';
                
            } catch (error) {
                console.error('Error exiting queue:', error);
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = '‚ùå Error exiting queue. Please try again.';
            }
        }

        function getTimeInQueue(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return `${seconds}s in queue`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m in queue`;
            const hours = Math.floor(minutes / 60);
            return `${hours}h ${minutes % 60}m in queue`;
        }

        function getTimeRemaining(endTime) {
            const remaining = endTime - Date.now();
            if (remaining <= 0) return 'Resolving...';
            
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m remaining`;
        }



        function playBattleFoundSound() {
            // Create audio context for battle found sound
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function resolveBattle(battle) {
            // Get current BTC price for resolution
            const finalPrice = currentBTCPrice || (Math.random() * 10000 + 40000); // Mock if no real price
            
            // Determine winner based on who was closer
            const userDistance = Math.abs(finalPrice - battle.user.price);
            const opponentDistance = Math.abs(finalPrice - battle.opponent.price);
            
            const userWins = userDistance < opponentDistance;
            const winner = userWins ? 'You' : battle.opponent.username;
            
            // Remove from active battles
            activeBattles = activeBattles.filter(b => b.id !== battle.id);
            updateQueueDisplay();
            
            // Show result
            const statusDiv = document.getElementById('status');
            if (userWins) {
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-green-900/20 border border-green-500/30 text-green-300';
                statusDiv.textContent = `üèÜ You won $${battle.potSize}! Final BTC: $${finalPrice.toLocaleString()} (closer to your $${battle.user.price.toLocaleString()})`;
            } else {
                statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-red-900/20 border border-red-500/30 text-red-300';
                statusDiv.textContent = `üíî You lost to @${battle.opponent.username}. Final BTC: $${finalPrice.toLocaleString()} (closer to their $${battle.opponent.price.toLocaleString()})`;
            }
        }

        // Initialize database connection and user authentication
        async function initializePvPSystem() {
            try {
                // Wait for scripts to be fully loaded
                let attempts = 0;
                const maxAttempts = 10;
                
                while (attempts < maxAttempts) {
                    if (typeof window.supabase !== 'undefined' && typeof window.PvPDatabase === 'function') {
                        break;
                    }
                    console.log(`Waiting for scripts to load... (${attempts + 1}/${maxAttempts})`);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    attempts++;
                }
                
                if (attempts >= maxAttempts) {
                    console.error('‚ùå Scripts failed to load after 2 seconds');
                    return;
                }
                
                // First initialize Supabase client
                if (typeof window.initializeSupabase === 'function') {
                    const initialized = window.initializeSupabase();
                    if (!initialized) {
                        console.error('‚ùå Supabase initialization failed');
                        return;
                    }
                } else {
                    console.error('‚ùå Supabase initialization function not found');
                    return;
                }
                
                // Wait a moment for Supabase to initialize
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Initialize database connection
                if (typeof window.PvPDatabase === 'function') {
                    pvpDB = new window.PvPDatabase();
                    console.log('‚úÖ PvP Database initialized');
                } else {
                    console.error('‚ùå PvPDatabase class not found');
                    return;
                }
                
                // Get current user from authentication
                const xResponse = await fetch('/auth/status', { credentials: 'include' });
                const xData = await xResponse.json();
                
                if (xData.authenticated) {
                    currentUser = xData.user;
                    
                    // Set the currentUser in the PvPDatabase instance
                    if (pvpDB) {
                        pvpDB.currentUser = currentUser;
                        console.log('üîó [PVP_INIT] Set currentUser in PvPDatabase:', currentUser);
                    }
                    
                    console.log('‚úÖ PvP system initialized for user:', currentUser.username);
                } else {
                    console.log('‚ÑπÔ∏è User not authenticated for PvP system');
                }
            } catch (error) {
                console.error('‚ùå Failed to initialize PvP system:', error);
            }
        }

        // Initialize Phantom wallet event listeners
        function initializePhantomListeners() {
            if (window.solana && window.solana.isPhantom) {
                // Listen for account changes
                window.solana.on('accountChanged', (publicKey) => {
                    if (publicKey) {
                        console.log('Phantom account changed:', publicKey.toString());
                        // Optionally refresh the connection
                    } else {
                        console.log('Phantom wallet disconnected');
                        // Handle disconnection
                        const statusDiv = document.getElementById('status');
                        statusDiv.className = 'mb-6 p-4 rounded-lg min-h-[60px] flex items-center justify-center text-center bg-yellow-900/20 border border-yellow-500/30 text-yellow-300';
                        statusDiv.textContent = '‚ö†Ô∏è Phantom wallet disconnected. Please reconnect.';
                        
                        // Reset button
                        const phantomButton = document.getElementById('phantomConnectBtn');
                        phantomButton.innerHTML = `
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                            </svg>
                            Connect Phantom
                        `;
                        phantomButton.onclick = connectPhantom;
                    }
                });

                // Listen for disconnect events
                window.solana.on('disconnect', () => {
                    console.log('Phantom wallet disconnected');
                });
            }
        }

        // Initialize queue display on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateQueueDisplay();
            
            // Initialize Phantom listeners
            setTimeout(() => {
                initializePhantomListeners();
            }, 1000);
            
            // Wait for all scripts to load before initializing PvP system
            setTimeout(() => {
                initializePvPSystem();
            }, 500);
            
            // Update queue times every 30 seconds
            setInterval(updateQueueDisplay, 30000);
        });
    </script>
</body>
</html>
